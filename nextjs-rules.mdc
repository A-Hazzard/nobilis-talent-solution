# Senior Software Engineering Rules for Next.js Projects

This document provides strict engineering guidelines to ensure code quality, maintainability, and security for Next.js projects.  
All contributors should adhere to the following rules, which are enforced throughout the codebase.

---

## 1. Package Management & Build Integrity

- **Use `pnpm` exclusively** for all package management tasks (install, update, remove).
- After any code or dependency change, always run `pnpm build`.
- If a build error occurs, fix the error, then re-run `pnpm build`.
- Repeat this process recursively until the project builds cleanly with zero errors or warnings.
- For development, use `pnpm dev` to start the local development server.

**Reference:**  
- `package.json` - Project dependencies and scripts

---

## 2. TypeScript Discipline & Types Organization

- **All type definitions must reside in the appropriate types directories:**
  - **Shared types** (used across frontend and backend) should be in [`shared/types/`](mdc:shared/types)
  - Application-wide types should be in [`types/`](mdc:types)
  - Component or library-specific types should be in [`lib/types/`](mdc:lib/types)
  - Do not define types or interfaces directly in component, helper, or utility files.
- **Prefer `type` over `interface`** for consistency across the codebase.
- **No `any` allowed** - Create appropriate type definitions for all variables and functions.
- **Always check dependencies before deleting types or functions** - Use `grep_search` to verify usage before removal.
- **Avoid type duplication** - Import and re-export from shared types instead of redefining.
- Always import types from their respective type files - avoid redefining types.
- Ensure type exports are properly named and documented.

**Shared Types Structure:**
- `shared/types/database.ts` - Database-related types
- `shared/types/entities.ts` - Core entity types
- `shared/types/api.ts` - API request/response types
- `shared/types/common.ts` - Common utility types
- `shared/types/auth.ts` - Authentication types

**References:**  
- `shared/types/` - Shared types across frontend and backend
- `types/` - Application-wide types
- `lib/types/` - Component or library-specific types

---

## 3. ESLint & Code Style

- **Never ignore ESLint rule violations.**
- Address all ESLint warnings and errors immediately.
- Run `pnpm lint` regularly to catch and fix style issues.
- Follow the established code style in the existing files for consistency.
- Use ESLint's auto-fix feature when possible: `pnpm lint --fix`.

**Reference:**  
- `eslint.config.mjs` - ESLint configuration

---

## 4. File Organization & Separation of Concerns

- **Keep all `page.tsx` and component files lean.**
  - Offload complex logic into helper functions and utilities.
- **API-related logic should reside in [`lib/helpers/`](mdc:lib/helpers) or specific feature directories.**
- **Shared utilities should reside in [`lib/utils/`](mdc:lib/utils) or [`utils/`](mdc:utils).**
- **Context providers should be in [`lib/contexts/`](mdc:lib/contexts) or [`context/`](mdc:context).**
- **Feature-specific code should be organized within their related directories** in `lib/` (e.g., `lib/chat/`, `lib/profile/`).
- Do not mix API logic with UI or utility logic.

**Folder Structure Best Practices:**
- **Shared code** → `shared/` (types, utilities, constants)
- **Frontend-specific** → `lib/` (helpers, utils, contexts, types)
- **Backend-specific** → `app/api/` (routes, models, helpers)
- **Components** → `components/` (UI components, pages)
- **Feature modules** → `lib/[feature]/` (e.g., `lib/chat/`, `lib/auth/`)

**References:**  
- `shared/` - Shared code (types, utilities, constants)
- `lib/helpers/` - API-related logic and helpers
- `lib/utils/` - Shared utilities
- `components/` - UI components and pages
- `app/` - Next.js app directory structure

---

## 5. Object-Oriented Programming Best Practices

- **Use Singleton Pattern for Services:**
  - Implement singleton pattern for service classes that manage global state
  - Use `getInstance()` method for consistent service access
  - Ensure thread-safe singleton implementation
- **Follow SOLID Principles:**
  - **Single Responsibility:** Each class/component should have one reason to change
  - **Open/Closed:** Open for extension, closed for modification
  - **Liskov Substitution:** Derived classes must be substitutable for base classes
  - **Interface Segregation:** Clients should not depend on interfaces they don't use
  - **Dependency Inversion:** Depend on abstractions, not concretions
- **Implement Proper Encapsulation:**
  - Use private fields and methods for internal implementation
  - Provide public interfaces for external access
  - Use readonly properties where appropriate
- **Use Composition Over Inheritance:**
  - Prefer composition and dependency injection over inheritance
  - Use interfaces to define contracts between components
  - Implement mixins or higher-order components for shared behavior
- **Service Layer Pattern:**
  - Create service classes for business logic and data access
  - Keep services focused on specific domains
  - Use dependency injection for service dependencies
- **Custom Hooks for State Management:**
  - Extract complex state logic into custom hooks
  - Return state and actions as tuples for clear separation
  - Use useCallback and useMemo for performance optimization
- **Utility Classes for Pure Functions:**
  - Create static utility classes for pure functions
  - Group related utility functions by domain
  - Use proper JSDoc documentation for all public methods

**Service Class Example:**
```typescript
export class CalendarService {
  private static instance: CalendarService;
  private readonly collectionName = 'calendar-events';

  private constructor() {}

  static getInstance(): CalendarService {
    if (!CalendarService.instance) {
      CalendarService.instance = new CalendarService();
    }
    return CalendarService.instance;
  }

  async createEvent(eventData: CreateEventData): Promise<ServiceResponse<CalendarEvent>> {
    // Implementation
  }
}
```

**Custom Hook Example:**
```typescript
export function useCalendar(): [CalendarState, CalendarActions] {
  // State management logic
  return [state, actions];
}
```

**Utility Class Example:**
```typescript
export class CalendarUtils {
  static parseCalendlyTime(timeString: string): TimeRange {
    // Pure function implementation
  }
}
```

---

## 6. Comments & Documentation

- **Remove redundant comments** that simply restate the meaning of well-named code.
- In helper and utility files:
  - Every function should have a concise block comment describing:
    - Its purpose
    - Its parameters
    - Its return value
- Document complex business logic with clear explanations.
- Update comments when code changes.

---

## 7. Security & Authentication/Authorization

- **Implement secure authentication practices** using JWT tokens with `jose` library.
- **Follow OWASP standards** to safeguard code from vulnerabilities.
- Never expose sensitive information (API keys, tokens) in client-side code.
- Always validate and sanitize user input, especially in form submissions.
- Use middleware for route protection where necessary.
- Store JWT tokens in secure HTTP-only cookies with proper expiration.

**References:**  
- `middleware.ts` - Next.js middleware for route protection
- `app/api/lib/helpers/auth.ts` - Authentication helpers

---

## 8. Component Structure & State Management

- Use appropriate state management solutions based on scope:
  - React's `useState` and `useReducer` for local component state
  - Context API for shared state across component tree
  - Zustand for application-wide state management
- Keep components focused on a single responsibility.
- Extract reusable UI elements into separate components.
- Implement proper error handling in components, especially for async operations.

---

## 9. Performance Optimization

- Implement proper code-splitting and lazy loading for pages and large components.
- Optimize images using Next.js Image component.
- Minimize unnecessary re-renders with memoization techniques.
- Use efficient data fetching patterns to prevent waterfalls.
- Implement proper caching strategies for API responses.
- **Use debouncing for search inputs** to prevent excessive API calls.
- **Implement proper cleanup** for event listeners, timeouts, and subscriptions.
- **Memoize expensive computations** and callback functions to prevent unnecessary re-renders.

---

## 10. Testing Best Practices

- Testing framework setup is planned for future implementation.
- Focus on manual testing of critical user flows during development.
- Implement proper error handling and logging for debugging.
- Use TypeScript for compile-time error catching.

**Reference:**  
- `package.json` - Jest configuration for future testing setup

---

## 11. Accessibility & Internationalization

- Ensure all components are accessible with proper ARIA attributes.
- Use semantic HTML elements.
- Support keyboard navigation.
- Prepare for internationalization by avoiding hardcoded strings where possible.

---

## 12. Code Cleanup & Dependency Management

- **Always check dependencies before deleting code:**
  - Use `grep_search` to find all usages of a type, function, or variable
  - Check both import statements and direct usage
  - Verify no code depends on the item before removal
- **Handle type conflicts properly:**
  - When importing types from multiple sources, ensure no naming conflicts
  - Use explicit imports or aliases to resolve conflicts
  - Prefer shared types over local duplicates
- **Clean up unused imports and exports:**
  - Remove unused imports to reduce bundle size
  - Update index files when removing exports
  - Verify all imports are still valid after changes
- **Follow the dependency chain:**
  - When removing a type/function, check what imports it
  - Update or remove dependent code accordingly
  - Ensure the build still passes after cleanup

---

## 13. Frontend-Backend Type Consistency

- **Before creating or modifying types that represent backend data:**
  - **Trace the data flow** from API endpoint to frontend usage
  - **Check the original API source** in `app/api/` routes to understand the data structure
  - **Verify database schema** if the type represents database entities
  - **Ensure shared types match** the actual API response structure
- **Type synchronization workflow:**
  1. **Identify the API endpoint** that provides the data
  2. **Examine the response structure** in the route handler
  3. **Check database models** if applicable (MongoDB schemas, Prisma models)
  4. **Update shared types** to match the actual data structure
  5. **Verify frontend usage** aligns with the updated types
- **Common patterns to check:**
  - **API response transformations** (e.g., `_id` to `id`, date formatting)
  - **Optional vs required fields** based on API behavior
  - **Nested object structures** and their relationships
  - **Array types** and their element structures
- **Validation approach:**
  - **Use TypeScript strict mode** to catch type mismatches
  - **Test API endpoints** to verify response structure
  - **Check runtime data** in browser dev tools
  - **Validate against database schema** for entity types

**References:**
- `app/api/` - API route handlers
- `shared/types/` - Shared type definitions
- `app/api/lib/models/` - Database models

---

**Summary:**  
Persistence: Keep going until the job is completely solved before ending your turn.
Plan than reflect: Plan thoroughly before every tool call then reflect on the outcome after
This project enforces strict discipline in type safety, code style, modularity, security, and build integrity.  
Use your tools don't guess: If you're unsure about code or files, open them - do not hallucinate.
**Always check dependencies before deleting code** - Use grep_search to verify usage patterns.
**Prefer shared types over duplicates** - Maintain single source of truth for types.
**Trace API data flow** - Check original backend source before creating/modifying types.
**Follow OOP principles** - Use singleton services, custom hooks, and utility classes for clean architecture.

All contributors must follow these rules to ensure a robust, maintainable, and secure codebase.
**Always check dependencies before deleting code** - Use grep_search to verify usage patterns.
**Prefer shared types over duplicates** - Maintain single source of truth for types.
**Trace API data flow** - Check original backend source before creating/modifying types.

All contributors must follow these rules to ensure a robust, maintainable, and secure codebase.